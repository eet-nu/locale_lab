import{MapMode as t}from"@codemirror/state";class RangeValue{eq(t){return this==t}range(t,e=t){return new Range(t,e,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0;RangeValue.prototype.point=false;RangeValue.prototype.mapMode=t.TrackDel;class Range{constructor(t,e,i){this.from=t;this.to=e;this.value=i}}function cmpRange(t,e){return t.from-e.from||t.value.startSide-e.value.startSide}class Chunk{constructor(t,e,i,n){this.from=t;this.to=e;this.value=i;this.maxPoint=n}get length(){return this.to[this.to.length-1]}findIndex(t,e,i,n=0){let s=i?this.to:this.from;for(let h=n,r=s.length;;){if(h==r)return h;let n=h+r>>1;let o=s[n]-t||(i?this.value[n].endSide:this.value[n].startSide)-e;if(n==h)return o>=0?h:r;o>=0?r=n:h=n+1}}between(t,e,i,n){for(let s=this.findIndex(e,-1e9,true),h=this.findIndex(i,1e9,false,s);s<h;s++)if(false===n(this.from[s]+t,this.to[s]+t,this.value[s]))return false}map(t,e){let i=[],n=[],s=[],h=-1,r=-1;for(let o=0;o<this.value.length;o++){let a,l,u=this.value[o],c=this.from[o]+t,f=this.to[o]+t;if(c==f){let t=e.mapPos(c,u.startSide,u.mapMode);if(null==t)continue;a=l=t;if(u.startSide!=u.endSide){l=e.mapPos(c,u.endSide);if(l<a)continue}}else{a=e.mapPos(c,u.startSide);l=e.mapPos(f,u.endSide);if(a>l||a==l&&u.startSide>0&&u.endSide<=0)continue}if(!((l-a||u.endSide-u.startSide)<0)){h<0&&(h=a);u.point&&(r=Math.max(r,l-a));i.push(u);n.push(a-h);s.push(l-h)}}return{mapped:i.length?new Chunk(n,s,i,r):null,pos:h}}}class RangeSet{constructor(t,e,i=RangeSet.empty,n){this.chunkPos=t;this.chunk=e;this.nextLayer=i;this.maxPoint=n}get length(){let t=this.chunk.length-1;return t<0?0:Math.max(this.chunkEnd(t),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let t=this.nextLayer.size;for(let e of this.chunk)t+=e.value.length;return t}chunkEnd(t){return this.chunkPos[t]+this.chunk[t].length}update(t){let{add:e=[],sort:i=false,filterFrom:n=0,filterTo:s=this.length}=t;let h=t.filter;if(0==e.length&&!h)return this;i&&(e=e.slice().sort(cmpRange));if(this.isEmpty)return e.length?RangeSet.of(e):this;let r=new LayerCursor(this,null,-1).goto(0),o=0,a=[];let l=new RangeSetBuilder;while(r.value||o<e.length)if(o<e.length&&(r.from-e[o].from||r.startSide-e[o].value.startSide)>=0){let t=e[o++];l.addInner(t.from,t.to,t.value)||a.push(t)}else if(1==r.rangeIndex&&r.chunkIndex<this.chunk.length&&(o==e.length||this.chunkEnd(r.chunkIndex)<e[o].from)&&(!h||n>this.chunkEnd(r.chunkIndex)||s<this.chunkPos[r.chunkIndex])&&l.addChunk(this.chunkPos[r.chunkIndex],this.chunk[r.chunkIndex]))r.nextChunk();else{(!h||n>r.to||s<r.from||h(r.from,r.to,r.value))&&(l.addInner(r.from,r.to,r.value)||a.push(new Range(r.from,r.to,r.value)));r.next()}return l.finishInner(this.nextLayer.isEmpty&&!a.length?RangeSet.empty:this.nextLayer.update({add:a,filter:h,filterFrom:n,filterTo:s}))}map(t){if(t.empty||this.isEmpty)return this;let e=[],i=[],n=-1;for(let s=0;s<this.chunk.length;s++){let h=this.chunkPos[s],r=this.chunk[s];let o=t.touchesRange(h,h+r.length);if(false===o){n=Math.max(n,r.maxPoint);e.push(r);i.push(t.mapPos(h))}else if(true===o){let{mapped:s,pos:o}=r.map(h,t);if(s){n=Math.max(n,s.maxPoint);e.push(s);i.push(o)}}}let s=this.nextLayer.map(t);return 0==e.length?s:new RangeSet(i,e,s,n)}between(t,e,i){if(!this.isEmpty){for(let n=0;n<this.chunk.length;n++){let s=this.chunkPos[n],h=this.chunk[n];if(e>=s&&t<=s+h.length&&false===h.between(s,t-s,e-s,i))return}this.nextLayer.between(t,e,i)}}iter(t=0){return HeapCursor.from([this]).goto(t)}get isEmpty(){return this.nextLayer==this}static iter(t,e=0){return HeapCursor.from(t).goto(e)}static compare(t,e,i,n,s=-1){let h=t.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=s));let r=e.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=s));let o=findSharedChunks(h,r,i);let a=new SpanCursor(h,o,s);let l=new SpanCursor(r,o,s);i.iterGaps(((t,e,i)=>compare(a,t,l,e,i,n)));i.empty&&0==i.length&&compare(a,0,l,0,0,n)}static eq(t,e,i=0,n){null==n&&(n=1e9);let s=t.filter((t=>!t.isEmpty&&e.indexOf(t)<0));let h=e.filter((e=>!e.isEmpty&&t.indexOf(e)<0));if(s.length!=h.length)return false;if(!s.length)return true;let r=findSharedChunks(s,h);let o=new SpanCursor(s,r,0).goto(i),a=new SpanCursor(h,r,0).goto(i);for(;;){if(o.to!=a.to||!sameValues(o.active,a.active)||o.point&&(!a.point||!o.point.eq(a.point)))return false;if(o.to>n)return true;o.next();a.next()}}static spans(t,e,i,n,s=-1){var h;let r=new SpanCursor(t,null,s,null===(h=n.filterPoint)||void 0===h?void 0:h.bind(n)).goto(e),o=e;let a=r.openStart;for(;;){let t=Math.min(r.to,i);if(r.point){n.point(o,t,r.point,r.activeForPoint(r.to),a);a=r.openEnd(t)+(r.to>t?1:0)}else if(t>o){n.span(o,t,r.active,a);a=r.openEnd(t)}if(r.to>i)break;o=r.to;r.next()}return a}static of(t,e=false){let i=new RangeSetBuilder;for(let n of t instanceof Range?[t]:e?lazySort(t):t)i.add(n.from,n.to,n.value);return i.finish()}}RangeSet.empty=new RangeSet([],[],null,-1);function lazySort(t){if(t.length>1)for(let e=t[0],i=1;i<t.length;i++){let n=t[i];if(cmpRange(e,n)>0)return t.slice().sort(cmpRange);e=n}return t}RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastFrom=-1e9;this.lastTo=-1e9;this.from=[];this.to=[];this.value=[];this.maxPoint=-1;this.setMaxPoint=-1;this.nextLayer=null}finishChunk(t){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;if(t){this.from=[];this.to=[];this.value=[]}}add(t,e,i){this.addInner(t,e,i)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(t,e,i)}addInner(t,e,i){let n=t-this.lastTo||i.startSide-this.last.endSide;if(n<=0&&(t-this.lastFrom||i.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");if(n<0)return false;250==this.from.length&&this.finishChunk(true);this.chunkStart<0&&(this.chunkStart=t);this.from.push(t-this.chunkStart);this.to.push(e-this.chunkStart);this.last=i;this.lastFrom=t;this.lastTo=e;this.value.push(i);i.point&&(this.maxPoint=Math.max(this.maxPoint,e-t));return true}addChunk(t,e){if((t-this.lastTo||e.value[0].startSide-this.last.endSide)<0)return false;this.from.length&&this.finishChunk(true);this.setMaxPoint=Math.max(this.setMaxPoint,e.maxPoint);this.chunks.push(e);this.chunkPos.push(t);let i=e.value.length-1;this.last=e.value[i];this.lastFrom=e.from[i]+t;this.lastTo=e.to[i]+t;return true}finish(){return this.finishInner(RangeSet.empty)}finishInner(t){this.from.length&&this.finishChunk(false);if(0==this.chunks.length)return t;let e=new RangeSet(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(t):t,this.setMaxPoint);this.from=null;return e}}function findSharedChunks(t,e,i){let n=new Map;for(let e of t)for(let t=0;t<e.chunk.length;t++)e.chunk[t].maxPoint<=0&&n.set(e.chunk[t],e.chunkPos[t]);let s=new Set;for(let t of e)for(let e=0;e<t.chunk.length;e++){let h=n.get(t.chunk[e]);null==h||(i?i.mapPos(h):h)!=t.chunkPos[e]||(null===i||void 0===i?void 0:i.touchesRange(h,h+t.chunk[e].length))||s.add(t.chunk[e])}return s}class LayerCursor{constructor(t,e,i,n=0){this.layer=t;this.skip=e;this.minPoint=i;this.rank=n}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(t,e=-1e9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(t,e,false);return this}gotoInner(t,e,i){while(this.chunkIndex<this.layer.chunk.length){let e=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(e)||this.layer.chunkEnd(this.chunkIndex)<t||e.maxPoint<this.minPoint))break;this.chunkIndex++;i=false}if(this.chunkIndex<this.layer.chunk.length){let n=this.layer.chunk[this.chunkIndex].findIndex(t-this.layer.chunkPos[this.chunkIndex],e,true);(!i||this.rangeIndex<n)&&this.setRangeIndex(n)}this.next()}forward(t,e){(this.to-t||this.endSide-e)<0&&this.gotoInner(t,e,true)}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9;this.value=null;break}{let t=this.layer.chunkPos[this.chunkIndex],e=this.layer.chunk[this.chunkIndex];let i=t+e.from[this.rangeIndex];this.from=i;this.to=t+e.to[this.rangeIndex];this.value=e.value[this.rangeIndex];this.setRangeIndex(this.rangeIndex+1);if(this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(t){if(t==this.layer.chunk[this.chunkIndex].value.length){this.chunkIndex++;if(this.skip)while(this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=t}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(t){return this.from-t.from||this.startSide-t.startSide||this.rank-t.rank||this.to-t.to||this.endSide-t.endSide}}class HeapCursor{constructor(t){this.heap=t}static from(t,e=null,i=-1){let n=[];for(let s=0;s<t.length;s++)for(let h=t[s];!h.isEmpty;h=h.nextLayer)h.maxPoint>=i&&n.push(new LayerCursor(h,e,i,s));return 1==n.length?n[0]:new HeapCursor(n)}get startSide(){return this.value?this.value.startSide:0}goto(t,e=-1e9){for(let i of this.heap)i.goto(t,e);for(let t=this.heap.length>>1;t>=0;t--)heapBubble(this.heap,t);this.next();return this}forward(t,e){for(let i of this.heap)i.forward(t,e);for(let t=this.heap.length>>1;t>=0;t--)heapBubble(this.heap,t);(this.to-t||this.value.endSide-e)<0&&this.next()}next(){if(0==this.heap.length){this.from=this.to=1e9;this.value=null;this.rank=-1}else{let t=this.heap[0];this.from=t.from;this.to=t.to;this.value=t.value;this.rank=t.rank;t.value&&t.next();heapBubble(this.heap,0)}}}function heapBubble(t,e){for(let i=t[e];;){let n=1+(e<<1);if(n>=t.length)break;let s=t[n];if(n+1<t.length&&s.compare(t[n+1])>=0){s=t[n+1];n++}if(i.compare(s)<0)break;t[n]=i;t[e]=s;e=n}}class SpanCursor{constructor(t,e,i,n=(()=>true)){this.minPoint=i;this.filterPoint=n;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=null;this.pointFrom=0;this.pointRank=0;this.to=-1e9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(t,e,i)}goto(t,e=-1e9){this.cursor.goto(t,e);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=t;this.endSide=e;this.openStart=-1;this.next();return this}forward(t,e){while(this.minActive>-1&&(this.activeTo[this.minActive]-t||this.active[this.minActive].endSide-e)<0)this.removeActive(this.minActive);this.cursor.forward(t,e)}removeActive(t){remove(this.active,t);remove(this.activeTo,t);remove(this.activeRank,t);this.minActive=findMinIndex(this.active,this.activeTo)}addActive(t){let e=0,{value:i,to:n,rank:s}=this.cursor;while(e<this.activeRank.length&&this.activeRank[e]<=s)e++;insert(this.active,e,i);insert(this.activeTo,e,n);insert(this.activeRank,e,s);t&&insert(t,e,this.cursor.from);this.minActive=findMinIndex(this.active,this.activeTo)}next(){let t=this.to,e=this.point;this.point=null;let i=this.openStart<0?[]:null,n=0;for(;;){let s=this.minActive;if(s>-1&&(this.activeTo[s]-this.cursor.from||this.active[s].endSide-this.cursor.startSide)<0){if(this.activeTo[s]>t){this.to=this.activeTo[s];this.endSide=this.active[s].endSide;break}this.removeActive(s);i&&remove(i,s)}else{if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>t){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}{let s=this.cursor.value;if(s.point)if(e&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)this.cursor.next();else{if(this.filterPoint(this.cursor.from,this.cursor.to,this.cursor.value,this.cursor.rank)){this.point=s;this.pointFrom=this.cursor.from;this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=s.endSide;this.cursor.from<t&&(n=1);this.cursor.next();this.forward(this.to,this.endSide);break}this.cursor.next()}else{this.addActive(i);this.cursor.next()}}}}if(i){let e=0;while(e<i.length&&i[e]<t)e++;this.openStart=e+n}}activeForPoint(t){if(!this.active.length)return this.active;let e=[];for(let i=this.active.length-1;i>=0;i--){if(this.activeRank[i]<this.pointRank)break;(this.activeTo[i]>t||this.activeTo[i]==t&&this.active[i].endSide>=this.point.endSide)&&e.push(this.active[i])}return e.reverse()}openEnd(t){let e=0;for(let i=this.activeTo.length-1;i>=0&&this.activeTo[i]>t;i--)e++;return e}}function compare(t,e,i,n,s,h){t.goto(e);i.goto(n);let r=n+s;let o=n,a=n-e;for(;;){let e=t.to+a-i.to||t.endSide-i.endSide;let n=e<0?t.to+a:i.to,s=Math.min(n,r);t.point||i.point?t.point&&i.point&&(t.point==i.point||t.point.eq(i.point))&&sameValues(t.activeForPoint(t.to+a),i.activeForPoint(i.to))||h.comparePoint(o,s,t.point,i.point):s>o&&!sameValues(t.active,i.active)&&h.compareRange(o,s,t.active,i.active);if(n>r)break;o=n;e<=0&&t.next();e>=0&&i.next()}}function sameValues(t,e){if(t.length!=e.length)return false;for(let i=0;i<t.length;i++)if(t[i]!=e[i]&&!t[i].eq(e[i]))return false;return true}function remove(t,e){for(let i=e,n=t.length-1;i<n;i++)t[i]=t[i+1];t.pop()}function insert(t,e,i){for(let i=t.length-1;i>=e;i--)t[i+1]=t[i];t[e]=i}function findMinIndex(t,e){let i=-1,n=1e9;for(let s=0;s<e.length;s++)if((e[s]-n||t[s].endSide-t[i].endSide)<0){i=s;n=e[s]}return i}export{Range,RangeSet,RangeSetBuilder,RangeValue};

